<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Aivoinko Aurinko Reality Simulator</title>
  <link rel="icon" type="image/jpeg" href="AiiAold.jpg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --glass-bg: rgba(0, 0, 0, 0.3);
      --glass-border: rgba(255, 255, 255, 0.15);
      --text-color: #ffffff;
      --accent-color: #00f3ff;
      --silver-gradient: linear-gradient(to bottom, #ffffff 0%, #c0c0c0 50%, #8a8a8a 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Rajdhani', sans-serif;
      color: var(--text-color);
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    }

    header {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      width: 90%;
      max-width: 1200px;
      padding: 20px 40px;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      /* Allow clicking links */
    }

    /* Desktop Layout */
    @media (min-width: 768px) {
      header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
    }

    .logo-container {
      text-align: center;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;

      /* Silver Gradient Text */
      background: var(--silver-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;

      text-shadow: 0 0 20px rgba(192, 192, 192, 0.5);

      /* Flash Animation */
      opacity: 0;
      animation: flashEntry 1.5s cubic-bezier(0.22, 1, 0.36, 1) forwards;
      animation-delay: 0.5s;
    }

    h2.subtitle {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      letter-spacing: 4px;
      color: #aaa;
      text-transform: uppercase;
      margin-top: -5px;

      opacity: 0;
      animation: fadeIn 1s ease forwards;
      animation-delay: 1.2s;
    }

    nav {
      display: flex;
      gap: 30px;
      margin-top: 15px;
    }

    @media (min-width: 768px) {
      nav {
        margin-top: 0;
      }
    }

    nav a {
      font-family: 'Orbitron', sans-serif;
      text-decoration: none;
      color: #fff;
      font-size: 1rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      padding: 5px 0;
      transition: color 0.3s;

      opacity: 0;
      animation: slideIn 0.8s ease forwards;
    }

    nav a:nth-child(1) {
      animation-delay: 1.5s;
    }

    nav a:nth-child(2) {
      animation-delay: 1.7s;
    }

    nav a:hover {
      color: var(--accent-color);
      text-shadow: 0 0 10px var(--accent-color);
    }

    nav a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--accent-color);
      transition: width 0.3s;
    }

    nav a:hover::after {
      width: 100%;
    }

    /* Animations */
    @keyframes flashEntry {
      0% {
        opacity: 0;
        transform: scale(1.1);
        filter: blur(10px);
      }

      10% {
        opacity: 1;
        filter: blur(0);
      }

      20% {
        opacity: 0.5;
      }

      30% {
        opacity: 1;
      }

      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    footer {
      position: fixed;
      bottom: 20px;
      bottom: env(safe-area-inset-bottom, 20px);
      /* Handle iPhone home bar */
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 10px 30px;
      border-radius: 30px;
      font-size: 0.9rem;
      display: flex;
      gap: 20px;
      pointer-events: none;
      width: 90%;
      /* Ensure it doesn't overflow on small screens */
      max-width: 600px;
      justify-content: center;
      white-space: nowrap;
      /* Prevent text wrapping issues */
    }

    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
      header {
        width: 95%;
        padding: 15px 20px;
      }

      footer {
        padding: 8px 15px;
        font-size: 0.75rem;
        gap: 10px;
        width: 95%;
      }

      /* Hide non-essential footer items on very small screens if needed, 
           but user said "footer disappears", so let's try to keep it visible 
           by ensuring high z-index and proper bottom spacing */

      /* Ensure tooltip doesn't cause overflow */
      #tooltip {
        max-width: 200px;
        /* Smaller tooltip on mobile */
      }

      #tooltip-content {
        width: 180px;
        left: 20px;
        bottom: 20px;
      }
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      background-color: #0f0;
      border-radius: 50%;
      box-shadow: 0 0 5px #0f0;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    /* Loading overlay */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 1s ease;
    }

    .loader {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Tooltip */
    #tooltip {
      position: absolute;
      display: none;
      pointer-events: none;
      z-index: 20;
    }

    #tooltip-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 60px;
      height: 2px;
      background: var(--accent-color);
      transform-origin: 0 50%;
      transform: rotate(-45deg);
      box-shadow: 0 0 5px var(--accent-color);
    }

    #tooltip-content {
      position: absolute;
      bottom: 42px;
      /* 60 * sin(45) approx 42.4 */
      left: 42px;
      /* 60 * cos(45) approx 42.4 */
      width: 250px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid var(--accent-color);
      border-radius: 0 5px 5px 5px;
      box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
      color: #fff;
      font-size: 0.9rem;
    }

    #tooltip-content h2 {
      margin-bottom: 5px;
      color: var(--accent-color);
      font-size: 1.2rem;
      text-transform: uppercase;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      font-size: 0.85rem;
      color: #ccc;
    }

    .data-value {
      color: #fff;
      font-weight: bold;
    }
  </style>
</head>

<body>

  <div id="loading">
    <div class="loader"></div>
  </div>

  <div id="tooltip">
    <div id="tooltip-line"></div>
    <div id="tooltip-content">
      <h2 id="planet-name">Planet</h2>
      <div class="data-row"><span>Mass:</span> <span id="planet-mass" class="data-value"></span></div>
      <div class="data-row"><span>Diameter:</span> <span id="planet-diameter" class="data-value"></span></div>
      <div class="data-row"><span>Temp:</span> <span id="planet-temp" class="data-value"></span></div>
    </div>
  </div>

  <header class="glass">
    <div class="logo-container">
      <h1>Aivoinko</h1>
      <h2 class="subtitle">Aurinko Reality Simulator</h2>
    </div>
    <nav>
      <a href="#">Pure Systems</a>
      <a href="#">DIY Realities</a>
    </nav>
  </header>

  <div id="canvas-container"></div>

  <footer class="glass">
    <div class="status-item">
      <div class="dot"></div>
      <span>System Online</span>
    </div>
    <div class="status-item">
      <span>Speed: 1x</span>
    </div>
    <div class="status-item">
      <span>Drag to Rotate &bull; Scroll to Zoom</span>
    </div>
  </footer>

  <!-- Import Map for Three.js -->
  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Configuration ---
    const SCENE_CONFIG = {
      sunRadius: 5,
      orbitScale: 10, // Multiplier for distance to make it fit but look good
      planetScale: 1, // Multiplier for planet size
      speedScale: 0.5,
    };

    // --- Texture Generation ---
    function createPlanetTexture(type, colors) {
      const width = 1024;
      const height = 512;
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Helper: Simple noise
      const noise = (x, y) => {
        const sin = Math.sin(x * 12.9898 + y * 78.233);
        return (sin * 43758.5453) % 1;
      };

      if (type === 'gas') {
        // Gas Giant: Horizontal bands
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        colors.forEach((color, index) => {
          gradient.addColorStop(index / (colors.length - 1), color);
        });
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Add turbulence
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const n = Math.sin(y * 0.05 + Math.sin(x * 0.01) * 5) * 20;
            data[i] = Math.min(255, Math.max(0, data[i] + n));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + n));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + n));
          }
        }
        ctx.putImageData(imageData, 0, 0);
      } else if (type === 'rocky') {
        // Rocky: Base color + noise/craters
        ctx.fillStyle = colors[0];
        ctx.fillRect(0, 0, width, height);

        // Noise
        for (let i = 0; i < 5000; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 2 + 1;
          ctx.fillStyle = Math.random() > 0.5 ? colors[1] : colors[2];
          ctx.globalAlpha = 0.1;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      } else if (type === 'earth') {
        // Earth-like: Water base, Land noise, Clouds
        ctx.fillStyle = colors[0]; // Water
        ctx.fillRect(0, 0, width, height);

        // Land (Simple Perlin-ish approximation using circles for now to avoid heavy lib)
        ctx.fillStyle = colors[1]; // Land
        for (let i = 0; i < 400; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 40 + 10;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Clouds
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.4;
        for (let i = 0; i < 600; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 30 + 5;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      } else if (type === 'sun') {
        // Sun surface
        const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width);
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      } else if (type === 'synthetic') {
        // Synthetic / Metallic Planet
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        colors.forEach((color, index) => {
          gradient.addColorStop(index / (colors.length - 1), color);
        });
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Add metallic shine/grid pattern
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2;

        // Grid lines
        for (let i = 0; i < width; i += 40) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, height);
          ctx.stroke();
        }
        for (let i = 0; i < height; i += 40) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(width, i);
          ctx.stroke();
        }

        // Random "tech" details
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        for (let i = 0; i < 50; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const w = Math.random() * 50 + 10;
          const h = Math.random() * 20 + 5;
          ctx.fillRect(x, y, w, h);
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    // Planet Data (Relative sizes and distances are approximated for visual appeal, not 1:1 scientific accuracy)
    const PLANETS = [
      {
        name: "Mercury", radius: 0.8, distance: 10, speed: 4.1, type: 'rocky', colors: ['#A5A5A5', '#808080', '#D3D3D3'],
        mass: "3.30 × 10^23 kg", diameter: "4,879 km", temp: "167 °C"
      },
      {
        name: "Venus", radius: 1.5, distance: 15, speed: 1.6, type: 'gas', colors: ['#E3BB76', '#D4AF37', '#C2B280'],
        mass: "4.87 × 10^24 kg", diameter: "12,104 km", temp: "464 °C"
      },
      {
        name: "Earth", radius: 1.6, distance: 22, speed: 1.0, type: 'earth', colors: ['#1E90FF', '#228B22', '#FFFFFF'],
        mass: "5.97 × 10^24 kg", diameter: "12,742 km", temp: "15 °C"
      },
      {
        name: "Mars", radius: 0.9, distance: 30, speed: 0.53, type: 'rocky', colors: ['#DD4C22', '#B22222', '#CD5C5C'],
        mass: "6.39 × 10^23 kg", diameter: "6,779 km", temp: "-65 °C"
      },
      {
        name: "Jupiter", radius: 3.5, distance: 45, speed: 0.08, type: 'gas', colors: ['#D6A566', '#8B4513', '#F4A460', '#DEB887'],
        mass: "1.90 × 10^27 kg", diameter: "139,820 km", temp: "-110 °C"
      },
      {
        name: "Saturn", radius: 3.0, distance: 65, speed: 0.03, type: 'gas', colors: ['#F4D03F', '#DAA520', '#EEE8AA'], hasRings: true,
        mass: "5.68 × 10^26 kg", diameter: "116,460 km", temp: "-140 °C"
      },
      {
        name: "Uranus", radius: 2.0, distance: 85, speed: 0.01, type: 'gas', colors: ['#ACE5EE', '#00CED1', '#40E0D0'],
        mass: "8.68 × 10^25 kg", diameter: "50,724 km", temp: "-195 °C"
      },
      {
        name: "Neptune", radius: 1.9, distance: 100, speed: 0.006, type: 'gas', colors: ['#3F54BA', '#4169E1', '#000080'],
        mass: "1.02 × 10^26 kg", diameter: "49,244 km", temp: "-200 °C"
      },
      {
        name: "Astroteles Aivoinko II", radius: 2.5, distance: 160, speed: 0.002, type: 'synthetic', colors: ['#C0C0C0', '#E8E8E8', '#A9A9A9'],
        mass: "9.99 × 10^99 kg", diameter: "1,000,000 km", temp: "NaN °C"
      }
    ];

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    // Mobile Detection
    const isMobile = window.innerWidth < 768;
    // Slower speed for mobile to make planets "touchable"
    const speedMultiplier = isMobile ? 0.15 : 1.0;

    const container = document.getElementById('canvas-container');
    scene.fog = new THREE.FogExp2(0x000000, 0.002); // Subtle depth cue

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 140, 280); // Significantly zoomed out for "far away" look

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // PERFORMANCE FIX: Cap pixel ratio to 2 to prevent overheating on high-DPI screens
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 600; // Increased to allow further zoom out
    controls.enablePan = false; // Disable panning to keep sun centered
    controls.target.set(0, 0, 0); // Explicitly lock target to sun

    // --- Raycaster Setup ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let activePlanet = null; // The planet currently selected (hovered or tapped)

    // Desktop: Hover Logic
    if (!isMobile) {
      window.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });
    }

    // Mobile: Tap Logic
    if (isMobile) {
      const sunLight = new THREE.PointLight(0xffffff, 3, 400); // Brighter sun
      sunLight.position.set(0, 0, 0);
      scene.add(sunLight);

      // --- Objects ---

      // 1. Sun
      // Procedural Fallback for "Eye of the Brain" in case image fails or for performance
      function createSunTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const context = canvas.getContext('2d');

        // Background
        const grad = context.createRadialGradient(256, 256, 20, 256, 256, 256);
        grad.addColorStop(0, '#ffaa00');
        grad.addColorStop(0.5, '#ff4400');
        grad.addColorStop(1, '#550000');
        context.fillStyle = grad;
        context.fillRect(0, 0, 512, 512);

        // "Brain/Eye" details
        context.strokeStyle = 'rgba(255, 200, 200, 0.5)';
        context.lineWidth = 2;
        for (let i = 0; i < 50; i++) {
          context.beginPath();
          context.moveTo(Math.random() * 512, Math.random() * 512);
          context.bezierCurveTo(Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512);
          context.stroke();
        }

        // Pupil
        context.fillStyle = 'rgba(0,0,0,0.8)';
        context.beginPath();
        context.arc(256, 256, 60, 0, Math.PI * 2);
        context.fill();

        return new THREE.CanvasTexture(canvas);
      }

      const textureLoader = new THREE.TextureLoader();
      const sunGeometry = new THREE.SphereGeometry(SCENE_CONFIG.sunRadius, 48, 48); // Reduced segments slightly for perf
      const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      scene.add(sun);

      // Attempt to load image, fallback to procedural if it fails (common in local file:// execution)
      textureLoader.load('AiiAold.jpg',
        (texture) => {
          sun.material.map = texture;
          sun.material.needsUpdate = true;
        },
        undefined,
        (err) => {
          console.warn("Sun texture failed to load (likely CORS if local). Using procedural fallback.");
          sun.material.map = createSunTexture();
          sun.material.needsUpdate = true;
        }
      );

      // Sun Glow (Fake Bloom)
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
      gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
      gradient.addColorStop(0.2, 'rgba(255, 100, 0, 0.4)');
      gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.1)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, 128, 128);

      const glowTexture = new THREE.CanvasTexture(canvas);
      const glowMaterial = new THREE.SpriteMaterial({
        map: glowTexture,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });
      const sunGlow = new THREE.Sprite(glowMaterial);
      sunGlow.scale.set(SCENE_CONFIG.sunRadius * 6, SCENE_CONFIG.sunRadius * 6, 1);
      sun.add(sunGlow);

      scene.add(sun);

      // 2. Starfield Background
      const starsGeometry = new THREE.BufferGeometry();
      const starsCount = 5000;
      const posArray = new Float32Array(starsCount * 3);

      for (let i = 0; i < starsCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 500; // Spread stars wide
      }

      starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      const starsMaterial = new THREE.PointsMaterial({
        size: 0.2,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
      });
      const starMesh = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starMesh);

      // 3. Planets
      const planetMeshes = [];
      const orbitLines = [];

      PLANETS.forEach(data => {
        // Group to hold planet and handle rotation/orbit
        const orbitGroup = new THREE.Group();
        scene.add(orbitGroup);

        // Orbit Path (Visual Line)
        const orbitCurve = new THREE.EllipseCurve(
          0, 0,            // ax, aY
          data.distance, data.distance, // xRadius, yRadius
          0, 2 * Math.PI,  // aStartAngle, aEndAngle
          false,           // aClockwise
          0                // aRotation
        );
        const points = orbitCurve.getPoints(100);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
        const orbitLine = new THREE.LineLoop(geometry, material);
        orbitLine.rotation.x = Math.PI / 2; // Lay flat on XZ plane
        scene.add(orbitLine);

        // Planet Mesh
        const planetGeometry = new THREE.SphereGeometry(data.radius, 64, 64); // Higher detail
        const texture = createPlanetTexture(data.type, data.colors);
        const planetMaterial = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: data.type === 'gas' ? 0.4 : 0.8,
          metalness: data.type === 'earth' ? 0.2 : 0.1
        });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);

        // Initial Position
        planet.position.x = data.distance;

        // Add to group? No, we'll animate position directly to avoid nested rotation complexity for now, 
        // or we can rotate the group. Let's rotate the group for orbit, and planet for axis.
        // Actually, rotating the group is easier for circular orbits.

        // Create a pivot object for the orbit
        const pivot = new THREE.Object3D();
        pivot.rotation.y = Math.random() * Math.PI * 2; // Random start angle
        scene.add(pivot);
        pivot.add(planet);

        // Saturn Rings
        let ring = null;
        if (data.hasRings) {
          const ringGeometry = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.2, 32);
          const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xA09070,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
          });
          ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          ring.rotation.y = 0.2; // Tilt
          planet.add(ring);
        }

        planetMeshes.push({
          mesh: planet,
          pivot: pivot,
          speed: data.speed * SCENE_CONFIG.speedScale,
          selfRotationSpeed: 0.01 + Math.random() * 0.02,
          data: data, // Store data for tooltip
          ring: ring // Store ring reference
        });
      });

      // --- Transition Animation ---
      let isTransitioning = false;
      function startTransition() {
        if (isTransitioning) return;
        isTransitioning = true;

        // Hide UI
        const header = document.querySelector('header');
        const footer = document.querySelector('footer');
        const tooltip = document.getElementById('tooltip');

        if (header) {
          header.style.transition = 'opacity 0.5s ease';
          header.style.opacity = '0';
        }
        if (footer) {
          footer.style.transition = 'opacity 0.5s ease';
          footer.style.opacity = '0';
        }
        if (tooltip) tooltip.style.display = 'none';

        // Animation Loop
        const startTime = Date.now();
        const duration = 1000; // 1 second for the suck effect

        function transitionLoop() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Easing: Cubic In (starts slow, ends fast)
          const ease = progress * progress * progress;

          // Scale down to almost zero
          const scale = 1 - ease;
          scene.scale.set(scale, scale, scale);

          // Rotate scene/camera for vortex effect
          scene.rotation.z += 0.05 * ease;

          if (progress < 1) {
            requestAnimationFrame(transitionLoop);
          } else {
            // Navigate
            window.location.href = 'brain.html';
          }
        }
        transitionLoop();
      }

      // --- Animation Loop ---
      function animate() {
        requestAnimationFrame(animate);

        // Rotate Sun
        sun.rotation.y += 0.002;

        // Rotate Stars (slowly)
        starMesh.rotation.y -= 0.0002;

        // Animate Planets
        planetMeshes.forEach(obj => {
          // Orbit
          obj.pivot.rotation.y += obj.speed * 0.01 * speedMultiplier; // Apply speedMultiplier

          // Self Rotation
          obj.mesh.rotation.y += obj.selfRotationSpeed;
        });

        controls.update();

        // --- Raycasting & Tooltip Update ---

        // Desktop: Continuous Raycast for Hover
        if (!isMobile) {
          raycaster.setFromCamera(mouse, camera);

          let cursor = 'default';
          activePlanet = null;

          // Check Sun Hover
          const sunIntersects = raycaster.intersectObject(sun);
          if (sunIntersects.length > 0) {
            cursor = 'pointer';
          }

          // Check Planet Hover
          const intersects = raycaster.intersectObjects(planetMeshes.map(p => p.mesh));
          if (intersects.length > 0) {
            const object = intersects[0].object;
            const planetObj = planetMeshes.find(p => p.mesh === object);
            if (planetObj) {
              activePlanet = planetObj;
              cursor = 'pointer';
            }
          }

          document.body.style.cursor = cursor;
        }

        // Display Tooltip if we have an active planet
        if (activePlanet) {
          // Update Content
          planetNameEl.textContent = activePlanet.data.name;
          planetMassEl.textContent = activePlanet.data.mass;
          planetDiameterEl.textContent = activePlanet.data.diameter;
          planetTempEl.textContent = activePlanet.data.temp;

          tooltip.style.display = 'block';

          // Update Position
          // CRITICAL FIX: Update matrices to ensure projection uses the latest camera/object transforms
          camera.updateMatrixWorld();
          activePlanet.mesh.updateMatrixWorld();

          const vector = new THREE.Vector3();
          activePlanet.mesh.getWorldPosition(vector);
          vector.project(camera);

          let x = (vector.x * .5 + .5) * window.innerWidth;
          let y = (-(vector.y * .5) + .5) * window.innerHeight;

          // Clamp to screen bounds (prevent overflow)
          const padding = 10;
          x = Math.max(padding, Math.min(window.innerWidth - padding, x));
          y = Math.max(padding, Math.min(window.innerHeight - padding, y));

          tooltip.style.left = `${x}px`;
          tooltip.style.top = `${y}px`;
        } else {
          tooltip.style.display = 'none';
        }

        renderer.render(scene, camera);
      }

      // --- Resize Handler ---
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start
      animate();

      // Remove loading screen
      setTimeout(() => {
        const loader = document.getElementById('loading');
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 1000);
      }, 1000);

  </script>
</body>

</html>