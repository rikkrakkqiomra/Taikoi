<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galactic Explorer - 3D Solar System</title>
  <style>
    :root {
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-color: #ffffff;
      --accent-color: #00f3ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text-color);
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    }

    header {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 15px 40px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      /* Let clicks pass through to canvas if needed, but usually header is small */
    }

    h1 {
      font-size: 1.5rem;
      letter-spacing: 4px;
      text-transform: uppercase;
      font-weight: 300;
      text-shadow: 0 0 10px var(--accent-color);
    }

    h1 span {
      font-weight: 700;
      color: var(--accent-color);
    }

    footer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 10px 30px;
      border-radius: 30px;
      font-size: 0.9rem;
      display: flex;
      gap: 20px;
      pointer-events: none;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      background-color: #0f0;
      border-radius: 50%;
      box-shadow: 0 0 5px #0f0;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    /* Loading overlay */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 1s ease;
    }

    .loader {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>

  <div id="loading">
    <div class="loader"></div>
  </div>

  <header class="glass">
    <h1>Galactic <span>Explorer</span></h1>
  </header>

  <div id="canvas-container"></div>

  <footer class="glass">
    <div class="status-item">
      <div class="dot"></div>
      <span>System Online</span>
    </div>
    <div class="status-item">
      <span>Speed: 1x</span>
    </div>
    <div class="status-item">
      <span>Drag to Rotate &bull; Scroll to Zoom</span>
    </div>
  </footer>

  <!-- Import Map for Three.js -->
  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Configuration ---
    const SCENE_CONFIG = {
      sunRadius: 5,
      orbitScale: 10, // Multiplier for distance to make it fit but look good
      planetScale: 1, // Multiplier for planet size
      speedScale: 0.5,
    };

    // --- Texture Generation ---
    function createPlanetTexture(type, colors) {
      const width = 1024;
      const height = 512;
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Helper: Simple noise
      const noise = (x, y) => {
        const sin = Math.sin(x * 12.9898 + y * 78.233);
        return (sin * 43758.5453) % 1;
      };

      if (type === 'gas') {
        // Gas Giant: Horizontal bands
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        colors.forEach((color, index) => {
          gradient.addColorStop(index / (colors.length - 1), color);
        });
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Add turbulence
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const n = Math.sin(y * 0.05 + Math.sin(x * 0.01) * 5) * 20;
            data[i] = Math.min(255, Math.max(0, data[i] + n));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + n));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + n));
          }
        }
        ctx.putImageData(imageData, 0, 0);
      } else if (type === 'rocky') {
        // Rocky: Base color + noise/craters
        ctx.fillStyle = colors[0];
        ctx.fillRect(0, 0, width, height);

        // Noise
        for (let i = 0; i < 5000; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 2 + 1;
          ctx.fillStyle = Math.random() > 0.5 ? colors[1] : colors[2];
          ctx.globalAlpha = 0.1;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      } else if (type === 'earth') {
        // Earth-like: Water base, Land noise, Clouds
        ctx.fillStyle = colors[0]; // Water
        ctx.fillRect(0, 0, width, height);

        // Land (Simple Perlin-ish approximation using circles for now to avoid heavy lib)
        ctx.fillStyle = colors[1]; // Land
        for (let i = 0; i < 400; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 40 + 10;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Clouds
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.4;
        for (let i = 0; i < 600; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 30 + 5;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      } else if (type === 'sun') {
        // Sun surface
        const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width);
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    // Planet Data (Relative sizes and distances are approximated for visual appeal, not 1:1 scientific accuracy)
    const PLANETS = [
      { name: "Mercury", radius: 0.8, distance: 10, speed: 4.1, type: 'rocky', colors: ['#A5A5A5', '#808080', '#D3D3D3'] },
      { name: "Venus", radius: 1.5, distance: 15, speed: 1.6, type: 'gas', colors: ['#E3BB76', '#D4AF37', '#C2B280'] }, // Venus looks like gas due to atmosphere
      { name: "Earth", radius: 1.6, distance: 22, speed: 1.0, type: 'earth', colors: ['#1E90FF', '#228B22', '#FFFFFF'] },
      { name: "Mars", radius: 0.9, distance: 30, speed: 0.53, type: 'rocky', colors: ['#DD4C22', '#B22222', '#CD5C5C'] },
      { name: "Jupiter", radius: 3.5, distance: 45, speed: 0.08, type: 'gas', colors: ['#D6A566', '#8B4513', '#F4A460', '#DEB887'] },
      { name: "Saturn", radius: 3.0, distance: 65, speed: 0.03, type: 'gas', colors: ['#F4D03F', '#DAA520', '#EEE8AA'], hasRings: true },
      { name: "Uranus", radius: 2.0, distance: 85, speed: 0.01, type: 'gas', colors: ['#ACE5EE', '#00CED1', '#40E0D0'] },
      { name: "Neptune", radius: 1.9, distance: 100, speed: 0.006, type: 'gas', colors: ['#3F54BA', '#4169E1', '#000080'] }
    ];

    // --- Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002); // Subtle depth cue

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 60, 140); // Zoomed out further

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 200;

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0x555555); // Slightly brighter background light
    scene.add(ambientLight);

    const sunLight = new THREE.PointLight(0xffffff, 3, 400); // Brighter sun
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    // --- Objects ---

    // 1. Sun
    const sunGeometry = new THREE.SphereGeometry(SCENE_CONFIG.sunRadius, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFD700,
      transparent: true,
      opacity: 0.9
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);

    // Sun Glow (Fake Bloom using Sprite)
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const context = canvas.getContext('2d');
    const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
    gradient.addColorStop(0.2, 'rgba(255, 100, 0, 0.4)');
    gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.1)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 128, 128);

    const glowTexture = new THREE.CanvasTexture(canvas);
    const glowMaterial = new THREE.SpriteMaterial({
      map: glowTexture,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const sunGlow = new THREE.Sprite(glowMaterial);
    sunGlow.scale.set(SCENE_CONFIG.sunRadius * 6, SCENE_CONFIG.sunRadius * 6, 1);
    sun.add(sunGlow);

    scene.add(sun);

    // 2. Starfield Background
    const starsGeometry = new THREE.BufferGeometry();
    const starsCount = 5000;
    const posArray = new Float32Array(starsCount * 3);

    for (let i = 0; i < starsCount * 3; i++) {
      posArray[i] = (Math.random() - 0.5) * 500; // Spread stars wide
    }

    starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starsMaterial = new THREE.PointsMaterial({
      size: 0.2,
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });
    const starMesh = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starMesh);

    // 3. Planets
    const planetMeshes = [];
    const orbitLines = [];

    PLANETS.forEach(data => {
      // Group to hold planet and handle rotation/orbit
      const orbitGroup = new THREE.Group();
      scene.add(orbitGroup);

      // Orbit Path (Visual Line)
      const orbitCurve = new THREE.EllipseCurve(
        0, 0,            // ax, aY
        data.distance, data.distance, // xRadius, yRadius
        0, 2 * Math.PI,  // aStartAngle, aEndAngle
        false,           // aClockwise
        0                // aRotation
      );
      const points = orbitCurve.getPoints(100);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
      const orbitLine = new THREE.LineLoop(geometry, material);
      orbitLine.rotation.x = Math.PI / 2; // Lay flat on XZ plane
      scene.add(orbitLine);

      // Planet Mesh
      const planetGeometry = new THREE.SphereGeometry(data.radius, 64, 64); // Higher detail
      const texture = createPlanetTexture(data.type, data.colors);
      const planetMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        roughness: data.type === 'gas' ? 0.4 : 0.8,
        metalness: data.type === 'earth' ? 0.2 : 0.1
      });
      const planet = new THREE.Mesh(planetGeometry, planetMaterial);

      // Initial Position
      planet.position.x = data.distance;

      // Add to group? No, we'll animate position directly to avoid nested rotation complexity for now, 
      // or we can rotate the group. Let's rotate the group for orbit, and planet for axis.
      // Actually, rotating the group is easier for circular orbits.

      // Create a pivot object for the orbit
      const pivot = new THREE.Object3D();
      pivot.rotation.y = Math.random() * Math.PI * 2; // Random start angle
      scene.add(pivot);
      pivot.add(planet);

      // Saturn Rings
      if (data.hasRings) {
        const ringGeometry = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.2, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0xA09070,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.6
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2;
        ring.rotation.y = 0.2; // Tilt
        planet.add(ring);
      }

      planetMeshes.push({
        mesh: planet,
        pivot: pivot,
        speed: data.speed * SCENE_CONFIG.speedScale,
        selfRotationSpeed: 0.01 + Math.random() * 0.02
      });
    });

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      // Rotate Sun
      sun.rotation.y += 0.002;

      // Rotate Stars (slowly)
      starMesh.rotation.y -= 0.0002;

      // Animate Planets
      planetMeshes.forEach(obj => {
        // Orbit
        obj.pivot.rotation.y += obj.speed * 0.01;

        // Self Rotation
        obj.mesh.rotation.y += obj.selfRotationSpeed;
      });

      controls.update();
      renderer.render(scene, camera);
    }

    // --- Resize Handler ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    animate();

    // Remove loading screen
    setTimeout(() => {
      const loader = document.getElementById('loading');
      loader.style.opacity = '0';
      setTimeout(() => loader.remove(), 1000);
    }, 1000);

  </script>
</body>

</html>